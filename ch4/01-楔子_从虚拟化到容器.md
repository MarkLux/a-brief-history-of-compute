# 01 楔子：从虚拟化到容器

### 虚拟化技术的诞生

虚拟化技术指的是将一个物理硬件虚拟为多个逻辑硬件的技术。

虚拟机技术最初的诞生是由于芯片的摩尔定理导致计算机硬件性能不断提升，而单一软件并不能充分应用硬件的性能，造成资源浪费，为此，硬件厂商通过虚拟化技术将一台物理机虚拟成多台计算机，旨在提高资源的利用率。

近年来，随着互联网规模的不断扩张，超大规模软件的性能消耗远超单一硬件所能提供的水平，进而催生了分布式系统，而分布式系统对集群中单一硬件的性能要求较低，而是强调多副本，这又进一步推动了虚拟化技术的演进。

#### 传统虚拟化

传统虚拟化技术最早可以追溯到上世纪60年代，在批处理系统上，人们通过Hypervisor软件程序来实现多用户，后来随着Unix/Linux等通过分时实现的多用户操作系统的出现，虚拟化技术销声匿迹了一段时间，直到90年代物理硬件规模出现冗余才重新登上历史舞台。

![img.png](img.png)

传统虚拟化技术的核心是Hypervisor软件，总的来说，Hypervisor软件会托管物理计算资源，并将其虚拟化为多个逻辑计算机，这些逻辑计算机也被称为虚拟机（VM）。

而在虚拟机上的用户程序，当其运行申请物理资源相关的“虚拟化敏感”指令时，这些请求便会被Hypervisor所拦截，然后根据虚拟化的资源粒度进行控制，最终转发给宿主物理机。

这种虚拟化技术也被称为全虚拟化，其特点是使用简单，Guest OS无需做任何修改，兼容性非常不错，但是相对的，性能上会有一定的影响（毕竟指令经过了一层转发）。这也是现在最为主流、应用最为广泛的虚拟化技术，代表产品有KVM，VirtualBox，VMWare等。

#### 半虚拟化 & 硬件辅助虚拟化

半虚拟化技术，或者叫准虚拟化技术，和全虚拟化很类似，但是加入了GuestOS的针对性优化。在这种方案下，GuestOS需要针对于虚拟化进行一定的改造，集成一些半虚拟化代码，从而能够和Hypervisor更好的进行联动，让Hypervisor不必再拦截所有的指令，从而实现性能的提升。

硬件辅助虚拟化则是通过在CPU等硬件资源中专门加入对虚拟化的支持，从而实现对全虚拟化和半虚拟化性能的优化。

上述两种技术的典型结合就是Xen。

#### 操作系统虚拟化

操作系统虚拟化是一种更为轻量的虚拟化实现，它的思路就是由操作系统内核来实现资源的隔离和分配，虚拟化出多个子环境，让每个子环境中的进程都认为自己是在一个独立的OS中运行，最初的目的是为了实现多用户之间的互相隔离。

操作系统级虚拟化技术最早可以追溯到UNIX时代，70年代末的UNIX 7操作系统的开发中，出现了chroot命令，这一命令可以改变某个进程的根目录/位置，从而建立其一个跟原操作系统完全隔离的文件目录环境，方便进行测试。该命令也被Linux所继承，对应的隔离环境又被称为jail。

在后来的Linux中，我们也可以看到一些可以对进程资源进行限制的API（如RLimit），但它们还算不上“虚拟化”，真正意义上的内核级虚拟化技术，在2006年左右，由Google的工程师所提出，当时称为Process Container。
这一技术是从谷歌内部的Borg系统（即后来的k8s）和GAE平台的实践中所沉淀出来的，并在2007年合并入Linux内核主干，此时的它有了一个新的名字：cgroups (Control Groups）

### 容器技术 D2/D3

通常我们将操作系统虚拟化中的一个逻辑OS称为容器，一个容器拥有以下两个特征：

- 从硬件上讲，一个容器拥有一定的硬件资源，例如CPU和内存，这些资源是由虚拟化技术基于物理宿主的硬件资源抽象分配而来
- 从软件上讲，一个容器本身就是一个独立的OS，其内部的进程等和其他的容器之间是完全隔离的

容器技术就是指在操作系统虚拟化中，实现这两个容器特征的关键技术，在Linux中对应的实现分别是cgroups和namespace。

#### cgroups

#### namespace

#### 延伸1：RunC & RunD

### Docker：重新定义软件交付 D4 & D5

#### 容器

#### 镜像

**UnionFS**

#### 基于Docker的软件交付